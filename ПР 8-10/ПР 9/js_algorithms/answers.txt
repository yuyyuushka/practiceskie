1.	В чем разница между временной сложностью O(n) и O(n²)? Приведите примеры алгоритмов с каждой сложностью.
O(n) — линейный рост времени выполнения с увеличением n. O(n²) — квадратичный рост (время растёт гораздо быстрее). Примеры: линейный поиск (O(n)), пузырьковая сортировка (O(n²)).

2.	Как работает алгоритм бинарного поиска и почему его сложность O(log n)?
Бинарный поиск делит отсортированный массив пополам на каждом шаге, отбрасывая одну из половин. Сложность O(log n), потому что количество операций уменьшается экспоненциально.

3.	Какие преимущества и недостатки у пузырьковой сортировки по сравнению с другими алгоритмами сортировки?
Преимущества: простота реализации. Недостатки: низкая эффективность на больших данных.

4.	Как можно оптимизировать функцию проверки на простое число для больших чисел?
Проверять делители только до √n, пропускать чётные числа кроме 2, использовать вероятностные тесты для очень больших чисел.

5.	В чем разница между рекурсивной и итеративной реализацией алгоритма Фибоначчи?
Рекурсивная версия проще, но неэффективна из-за повторных вычислений. Итеративная версия быстрее и использует меньше памяти.

6.	Какие методы отладки вы использовали при реализации алгоритмов?
Пошаговое выполнение, вывод промежуточных значений, проверка граничных случаев, использование отладчика.

7.	Как работает алгоритм Евклида для нахождения НОД и почему он эффективен?
Алгоритм Евклида находит НОД путем последовательного деления чисел. Эффективен благодаря быстрому уменьшению чисел.

8.	Какие edge cases (крайние случаи) нужно учитывать при реализации алгоритмов работы с массивами?
Пустые массивы, массивы из одного элемента, отсортированные/несортированные данные, дубликаты, отрицательные числа, переполнение.

9.	Как можно улучшить функцию удаления дубликатов для работы с большими массивами?
Использовать хэш-таблицы для отслеживания уникальных элементов, что даёт сложность O(n).

10.	Какие принципы написания чистого кода вы применили при реализации алгоритмов?
Чёткие названия переменных/функций, разделение логики на небольшие функции, избегание повторения кода, комментарии для сложных частей.
