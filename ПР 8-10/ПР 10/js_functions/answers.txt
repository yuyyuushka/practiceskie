1.	В чем разница между Function Declaration и Function Expression в контексте hoisting (поднятия)?
Function Declaration полностью поднимается (можно вызвать до объявления). Function Expression не поднимается — переменная поднимается, но не инициализируется функцией.

2.	Как работают rest parameters (...args) и в чем их отличие от arguments object?
Rest parameters создают настоящий массив из оставшихся аргументов. Arguments — устаревший array-like объект, недоступный в стрелочных функциях.

3.	Что такое замыкание (closure) и как оно связано с лексической областью видимости?
Замыкание — способность функции запоминать область видимости, в которой она была создана. Лексическая область видимости определяет доступность переменных на момент создания функции.

4.	Когда следует использовать рекурсию, а когда итерацию? Какие преимущества и недостатки у каждого подхода?
Рекурсия удобна для задач с рекурсивной структурой (деревья), но может привести к переполнению стека. Итерация эффективнее по памяти, но код может быть сложнее.

5.	Как работают функции высшего порядка и какие встроенные методы массивов являются таковыми?
Функции высшего порядка принимают или возвращают другие функции. Примеры: map, filter, reduce, forEach.

6.	Что такое каррирование и какие практические преимущества оно дает?
Каррирование преобразует функцию от многих аргументов в цепочку функций от одного аргумента. Даёт возможность частичного применения и композиции.

7.	Как работает мемоизация и в каких случаях ее использование наиболее эффективно?
Мемоизация кеширует результаты вызовов функций. Эффективна для чистых функций с дорогими вычислениями и повторяющимися аргументами.

8.	В чем разница между debounce и throttle и когда следует использовать каждый подход?
Debounce откладывает выполнение до паузы в вызовах. Throttle ограничивает частоту выполнения. Debounce — для поиска, Throttle — для скролла/ресайза.

9.	Как функции-генераторы (function*) отличаются от обычных функций?
Функции-генераторы можно приостанавливать (yield) и возобновлять. Возвращают итератор и сохраняют состояние между вызовами.

10.	Какие принципы функционального программирования вы применили в ходе работы и в чем их benefits?
Чистые функции, неизменяемость данных, композиция. Benefits: предсказуемость, тестируемость, отсутствие побочных эффектов.

