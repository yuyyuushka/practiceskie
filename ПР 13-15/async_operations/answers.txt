1.	В чем разница между Promise.then().catch() и async/await с try/catch? Когда следует использовать каждый подход?
Promise.then().catch(): Функциональный стиль, лучше для цепочек преобразований. Может привести к "callback hell" при сложных цепочках.
async/await: Императивный стиль, читабельнее для последовательных операций. Лучше для сложной логики потока выполнения.
Использовать: async/await для бизнес-логики, Promise для цепочек преобразований.

2.	Как работает Promise.all и что происходит, если один из промисов в массиве завершается ошибкой?
Работа: Выполняет промисы параллельно, ждет все.
При ошибке: Немедленно отклоняется с первой ошибкой, остальные промисы продолжают выполняться но игнорируются.

3.	В чем разница между Promise.all, Promise.race и Promise.allSettled? Приведите практические примеры использования каждого.
all: Все успешно или первая ошибка (параллельное выполнение)
race: Первый завершенный (успех/ошибка) (таймауты, конкурентность)
allSettled: Все завершены с результатами (анализ всех операций)

4.	Как реализовать повторные попытки (retry logic) для асинхронных операций с экспоненциальной задержкой?
Увеличивать задержку между попытками (baseDelay * 2^attempt)
Ограничить максимальное количество попыток
Использовать рекурсию или цикл с await

5.	Что такое "состояние гонки" (race condition) в асинхронном коде и как его избежать?
Проблема: Неопределенный порядок выполнения асинхронных операций
Решение: Отмена предыдущих запросов (AbortController), синхронизация через флаги, использование последнего результата

6.	Как работает кэширование результатов асинхронных запросов и какие стратегии кэширования существуют?
Стратегии: In-memory кэш, TTL (время жизни), инвалидация по ключу, stale-while-revalidate
Реализация: Map/WeakMap для хранения, мемоизация функций

7.	Какие методы оптимизации производительности можно применить при работе с множественными асинхронными операциями?
Параллельное выполнение (Promise.all)
Ограничение одновременных операций (пулы)
Ленивая загрузка и пагинация
Прерывание ненужных запросов

8.	Как обрабатывать ошибки в цепочках промисов и предотвращать "проглатывание" ошибок?
Всегда возвращать промисы в цепочках
Использовать .catch() в конце цепочек
Не забывать throw error в catch блоках
Использовать Promise.allSettled для частичных успехов

9.	В чем преимущества использования async/await по сравнению с традиционными промисами и обратными вызовами?
Читабельность (похоже на синхронный код)
Упрощенная обработка ошибок (try/catch)
Упрощенная отладка (стектрейсы)
Проще комбинировать операции

10.	Как отлаживать асинхронный код и какие инструменты разработчика наиболее полезны для этого?
Инструменты: DevTools async stack traces, точки останова в await
Методы: console.log с временными метками, обработка глобальных ошибок
Практики: Изоляция асинхронной логики, использование TypeScript
