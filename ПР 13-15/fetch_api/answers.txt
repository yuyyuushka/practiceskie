1.	В чем разница между Fetch API и XMLHttpRequest? Какие преимущества предоставляет Fetch API?
Fetch API - современная замена XMLHttpRequest, использует Promises, имеет более чистый синтаксис, автоматически обрабатывает JSON, не поддерживает прогресс загрузки по умолчанию, требует ручной обработки ошибок HTTP.

2.	Как обрабатываются ошибки в Fetch API и почему ответ с HTTP статусом 404 не вызывает reject промиса?
Fetch не отклоняет промис при HTTP ошибках (404, 500), только при сетевых сбоях. Response.ok показывает успешность (статус 200-299). Нужно проверять response.ok или response.status вручную.

3.	Какие методы HTTP поддерживает Fetch API и в каких случаях используется каждый из них?
GET (получение), POST (создание), PUT (полное обновление), PATCH (частичное обновление), DELETE (удаление), HEAD (только заголовки), OPTIONS (CORS). Указываются в options.method.

4.	Как работать с заголовками запроса и ответа в Fetch API? Приведите примеры полезных заголовков.
Заголовки запроса - через options.headers. Заголовки ответа - response.headers. Полезные: Content-Type, Authorization, Accept, Cache-Control, User-Agent.

5.	В чем разница между PUT и PATCH запросами и когда следует использовать каждый метод?
PUT заменяет весь ресурс, PATCH - только указанные поля. PUT идемпотентен, PATCH - нет. Используйте PUT когда известен полный объект, PATCH для частичных обновлений.

6.	Как реализовать авторизацию в Fetch API (Basic Auth, Bearer Token, OAuth2)?
Basic Auth: заголовок Authorization с base64. Bearer Token: Authorization: Bearer <token>. OAuth2: Bearer токены, refresh токены. Все через заголовки.

7.	Какие способы отмены запросов существуют в Fetch API и когда их следует использовать?
AbortController + signal. Передавать signal в options, вызывать abort() для отмены. Использовать при навигации, таймаутах, отмене пользователем.

8.	Как работать с разными форматами данных (JSON, FormData, Blob, ArrayBuffer) в Fetch API?
JSON: JSON.stringify() и response.json(). FormData: для файлов и форм. Blob: для бинарных данных. ArrayBuffer: для низкоуровневых бинарных операций.

9.	Как оптимизировать производительность при работе с множественными запросами (параллельное выполнение, кэширование)?
Promise.all для параллельных независимых запросов. Последовательные запросы для зависимых данных. Кэширование результатов, мемоизация, HTTP кэширование.

10.	Какие лучшие практики существуют для работы с Fetch API в production приложениях?
Обработка всех ошибок, таймауты, повторные попытки, кэширование, ограничение частоты запросов, индикаторы загрузки, отмена устаревших запросов, безопасность (CSRF), мониторинг.
